
var fs = require('fs');
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var noop = function () {};

/**
 * Creates a new instance of the database
 * @param path Path to the data file
 * @param opts Additional options to pass into the database
 * @constructor
 */
function Db(path, opts) {
  EventEmitter.call(this);

  opts = opts || {};
  this._path = path;
  this._map = {};
  this._uuid = 0;
  this._connected = false;
  this._inmemory = opts.memory;

  this._connect();
}

util.inherits(Db, EventEmitter);


/**
 * Checks and reads in the data file
 * @private
 */
Db.prototype._connect = function () {
  // Do not try to reconnect if it is already connected
  if (this._connected) return;

  // If it is in memory, just fire the connection event
  if (this._inmemory) {
    this._emitConnect(null);
    return;
  }

  // This is the case where it is not connected and it is a file database
  var self = this;
  var path = this._path;

  fs.exists(path, checkExists);

  function checkExists(exists) {
    if (exists) readFile();
  }

  function readFile() {
    fs.readFile(path, 'utf8', function (err, data) {
      self._readData(data);
      self._emitConnect(err);
    });
  }
}


/**
 * Actions to be done on connecting to the datafile
 * @param err Error argument generated when trying to connect
 * @private
 */
Db.prototype._emitConnect = function (err) {
  this._connected = true;
  this.emit("connect", err);
}


/**
 * Reads the raw data from the datafile and populates the internal data map
 * of this instance
 * @param data Content of the data file
 * @private
 */
Db.prototype._readData = function (data) {
  data = data.split('\n');
  data = data.filter(function (datum) {
    return datum.trim() != "";
  });
  data = data.map(function (datum) {
    return JSON.parse(datum);
  });

  for (var i = 0; i  < data.length; i++) {
    var id = data[i]._id;
    this._map[id] = data[i];
  }
}


/**
 * Store a value on the database
 * @param obj Object to store in the database. If the object has an _id, this will
 * be an update. Otherwise this will be a create.
 * @param onWrite Callback to be called once the data has been written to disk
 * @returns {*} _id of the object in the database
 */
Db.prototype.set = function (obj, onWrite) {
  // We are connected to the database, do the write now
  var map = this._map;
  var id = null;
  var self = this;

  onWrite = onWrite || noop;

  // Add the id to the object
  obj = obj || {};
  id = obj._id || this.uuid();
  obj._id = id;
  map[id] = obj;

  // Write to file
  fs.appendFile(this._path, JSON.stringify(obj) + '\n', onAppend);

  function onAppend(err) {
    if (!self._connected) self._emitConnect(err);
    onWrite(err, obj);
  }

  return id;
}

/**
 * Gets a value from the database
 * @param id Id of the record
 * @param onResult Callback that will be given the result
 */
Db.prototype.get = function (id, onResult) {
  var self = this;
  onResult = onResult || noop;

  // Keep postponing the get till we are connected to the database
  if (!this._connected) {
    setTimeout(function () {
      self.get(id, onResult);
    }, 0);
    return;
  }

  // We are connected to the database, we can look up the value now
  var value = this._map[id];
  // Special case to handle items that have been removed
  onResult(null, value._removed ? null : value);
}


/**
 * Removes a value from the database
 * @param id Id of the record
 * @param onRemove Callback when the remove has been written to disk
 */
Db.prototype.remove = function (id, onRemove) {
  var obj = { _id:id, _removed:true };

  this._map[id] = obj;
  this.set(obj, onRemove);
}


/**
 * Finds documents in the database matching the filterFunction
 * @param filterFn Function that is used to filter across the documents
 * @param onFind Callback when results have been found
 */
Db.prototype.find = function (filterFn, onFind) {
  var self = this;

  if (!this._connected) {
    setTimeout(function () {
      self.find(filterFn, onFind);
    }, 1);
    return;
  }

  var map = this._map;
  var results = [];

  filterFn = filterFn || function () { return true; };
  onFind = onFind || noop;

  for (var id in map) {
    if (map.hasOwnProperty(id)) {
      if (filterFn(map[id])) {
        results.push(map[id]);
      }
    }
  }

  onFind(null, results);
}

Db.prototype.uuid = function () {
  return this._uuid++;
}

module.exports = Db;